'use server'

import { 
  Class, 
  ClassSession, 
  ClassWithMembers, 
  ClassJoinResult,
  ClassSessionResult,
  ClassSessionResults,
  ParticipantStatus
} from '@/types/quiz'
import { supabaseServer } from '@/lib/supabase-server'
import { requireTeacher } from '@/lib/auth'

export interface CreateClassResult {
  success: boolean
  class?: Class
  error?: string
}

export interface CreateClassSessionResult {
  success: boolean
  classSession?: ClassSession
  error?: string
}

/**
 * Create a new class
 */
export async function createClassAction(formData: FormData): Promise<CreateClassResult> {
  const name = formData.get('name') as string
  const grade = formData.get('grade') as string
  const subject = formData.get('subject') as string
  const orgId = formData.get('orgId') as string

  if (!name?.trim()) {
    return {
      success: false,
      error: 'Klassnamn krävs'
    }
  }

  try {
    // Verify teacher authentication
    const user = await requireTeacher()
    
    const supabase = supabaseServer()

    // If orgId is provided, verify membership
    if (orgId) {
      const { data: membership, error: membershipError } = await supabase
        .from('org_members')
        .select('*')
        .eq('org_id', orgId)
        .eq('user_id', user.id)
        .eq('status', 'active')
        .single()

      if (membershipError || !membership) {
        return {
          success: false,
          error: 'Du har inte behörighet att skapa klasser i denna organisation'
        }
      }
    }

    // Create the class
    const { data: classData, error: classError } = await supabase
      .from('classes')
      .insert({
        owner_id: user.id,
        org_id: orgId || null,
        name: name.trim(),
        grade: grade?.trim() || null,
        subject: subject?.trim() || null
        // invite_code will be auto-generated by trigger
      })
      .select()
      .single()

    if (classError) {
      throw classError
    }

    return {
      success: true,
      class: {
        id: classData.id,
        ownerId: classData.owner_id,
        orgId: classData.org_id,
        name: classData.name,
        grade: classData.grade,
        subject: classData.subject,
        inviteCode: classData.invite_code,
        createdAt: new Date(classData.created_at),
        updatedAt: new Date(classData.updated_at)
      }
    }
  } catch (error) {
    console.error('Error creating class:', error)
    return {
      success: false,
      error: 'Det gick inte att skapa klassen'
    }
  }
}

/**
 * Get classes for current teacher
 */
export async function getTeacherClasses(): Promise<ClassWithMembers[]> {
  try {
    const user = await requireTeacher()
    const supabase = supabaseServer()

    // Get classes with member counts
    const { data: classes, error: classesError } = await supabase
      .from('classes')
      .select(`
        *,
        class_members(
          id,
          user_id,
          alias,
          role,
          joined_at,
          status
        )
      `)
      .eq('owner_id', user.id)
      .order('created_at', { ascending: false })

    if (classesError) {
      throw classesError
    }

    return classes.map(classData => ({
      id: classData.id,
      ownerId: classData.owner_id,
      orgId: classData.org_id,
      name: classData.name,
      grade: classData.grade,
      subject: classData.subject,
      inviteCode: classData.invite_code,
      createdAt: new Date(classData.created_at),
      updatedAt: new Date(classData.updated_at),
      members: classData.class_members
        .filter((m: { status: string }) => m.status === 'active')
        .map((member: { 
          id: string;
          user_id: string | null;
          alias: string | null;
          role: string;
          joined_at: string;
          status: string;
        }) => ({
          id: member.id,
          classId: classData.id,
          userId: member.user_id,
          alias: member.alias,
          role: member.role,
          joinedAt: new Date(member.joined_at),
          status: member.status
        })),
      memberCount: classData.class_members.filter((m: { status: string; role: string }) => m.status === 'active' && m.role === 'student').length
    }))
  } catch (error) {
    console.error('Error getting teacher classes:', error)
    return []
  }
}

/**
 * Join a class as a student
 */
export async function joinClassAction(formData: FormData): Promise<ClassJoinResult> {
  const inviteCode = formData.get('inviteCode') as string
  const alias = formData.get('alias') as string
  const userId = formData.get('userId') as string // Optional for authenticated users

  if (!inviteCode?.trim() || !alias?.trim()) {
    return {
      success: false,
      error: 'Klasskod och alias krävs',
      errorCode: 'INVALID_CODE'
    }
  }

  try {
    const supabase = supabaseServer()

    // Find class by invite code
    const { data: classData, error: classError } = await supabase
      .from('classes')
      .select('*')
      .eq('invite_code', inviteCode.trim().toUpperCase())
      .single()

    if (classError || !classData) {
      return {
        success: false,
        error: 'Klassen hittades inte. Kontrollera att koden är korrekt.',
        errorCode: 'INVALID_CODE'
      }
    }

    // Check if alias is already taken in this class
    const { data: existingAlias } = await supabase
      .from('class_members')
      .select('id')
      .eq('class_id', classData.id)
      .eq('alias', alias.trim())
      .eq('status', 'active')
      .single()

    if (existingAlias) {
      return {
        success: false,
        error: 'Detta namn används redan i klassen. Välj ett annat namn.',
        errorCode: 'ALIAS_TAKEN'
      }
    }

    // Check if user is already a member (for authenticated users)
    if (userId) {
      const { data: existingMember } = await supabase
        .from('class_members')
        .select('id')
        .eq('class_id', classData.id)
        .eq('user_id', userId)
        .eq('status', 'active')
        .single()

      if (existingMember) {
        return {
          success: false,
          error: 'Du är redan medlem i denna klass.',
          errorCode: 'ALREADY_MEMBER'
        }
      }
    }

    // Add student to class
    const { data: member, error: memberError } = await supabase
      .from('class_members')
      .insert({
        class_id: classData.id,
        user_id: userId || null,
        alias: alias.trim(),
        role: 'student',
        status: 'active'
      })
      .select()
      .single()

    if (memberError) {
      throw memberError
    }

    return {
      success: true,
      class: {
        id: classData.id,
        ownerId: classData.owner_id,
        orgId: classData.org_id,
        name: classData.name,
        grade: classData.grade,
        subject: classData.subject,
        inviteCode: classData.invite_code,
        createdAt: new Date(classData.created_at),
        updatedAt: new Date(classData.updated_at)
      },
      member: {
        id: member.id,
        classId: member.class_id,
        userId: member.user_id,
        alias: member.alias,
        role: member.role,
        joinedAt: new Date(member.joined_at),
        status: member.status
      }
    }
  } catch (error) {
    console.error('Error joining class:', error)
    return {
      success: false,
      error: 'Det gick inte att gå med i klassen'
    }
  }
}

/**
 * Create a class session (link a quiz session to a class)
 */
export async function createClassSessionAction(formData: FormData): Promise<ClassSessionResult> {
  const classId = formData.get('classId') as string
  const sessionId = formData.get('sessionId') as string
  const quizId = formData.get('quizId') as string

  if (!classId || !sessionId || !quizId) {
    return {
      success: false,
      error: 'Klass-ID, sessions-ID och quiz-ID krävs'
    }
  }

  try {
    const user = await requireTeacher()
    const supabase = supabaseServer()

    // Verify class ownership
    const { data: classData, error: classError } = await supabase
      .from('classes')
      .select('*')
      .eq('id', classId)
      .eq('owner_id', user.id)
      .single()

    if (classError || !classData) {
      return {
        success: false,
        error: 'Klassen hittades inte eller du har inte behörighet'
      }
    }

    // Verify session ownership
    const { data: sessionData, error: sessionError } = await supabase
      .from('sessions')
      .select('*')
      .eq('id', sessionId)
      .eq('teacher_id', user.id)
      .single()

    if (sessionError || !sessionData) {
      return {
        success: false,
        error: 'Sessionen hittades inte eller du har inte behörighet'
      }
    }

    // Create class session
    const { data: classSession, error: classSessionError } = await supabase
      .from('class_sessions')
      .insert({
        class_id: classId,
        session_id: sessionId,
        quiz_id: quizId,
        status: 'open'
      })
      .select()
      .single()

    if (classSessionError) {
      throw classSessionError
    }

    return {
      success: true,
      classSession: {
        id: classSession.id,
        classId: classSession.class_id,
        sessionId: classSession.session_id,
        quizId: classSession.quiz_id,
        status: classSession.status,
        startedAt: new Date(classSession.started_at),
        endedAt: classSession.ended_at ? new Date(classSession.ended_at) : undefined,
        createdAt: new Date(classSession.created_at)
      }
    }
  } catch (error) {
    console.error('Error creating class session:', error)
    return {
      success: false,
      error: 'Det gick inte att skapa klasssessionen'
    }
  }
}

/**
 * Get class session results
 */
export async function getClassSessionResults(classSessionId: string): Promise<ClassSessionResults | null> {
  try {
    const user = await requireTeacher()
    const supabase = supabaseServer()

    // Get class session with related data
    const { data: classSession, error: classSessionError } = await supabase
      .from('class_sessions')
      .select(`
        *,
        classes!inner(id, name, owner_id),
        sessions!inner(id, code, status, started_at, ended_at),
        quizzes!inner(id, title)
      `)
      .eq('id', classSessionId)
      .single()

    if (classSessionError || !classSession) {
      return null
    }

    // Verify ownership
    if (classSession.classes.owner_id !== user.id) {
      return null
    }

    // Get session participants
    const { data: participants, error: participantsError } = await supabase
      .from('session_participants')
      .select('*')
      .eq('session_id', classSession.session_id)
      .order('joined_at', { ascending: true })

    if (participantsError) {
      throw participantsError
    }

    // Get attempts/results for participants
    const { data: attempts, error: attemptsError } = await supabase
      .from('attempts')
      .select('*')
      .eq('session_id', classSession.session_id)
      .not('finished_at', 'is', null)

    if (attemptsError) {
      throw attemptsError
    }

    // Calculate stats
    const submittedCount = attempts.length
    const totalParticipants = participants.length
    const totalScore = attempts.reduce((sum: number, attempt: { score?: number }) => {
      const score = attempt.score || 0
      return sum + score
    }, 0)
    const averageScore = submittedCount > 0 ? totalScore / submittedCount : 0
    
    const totalTime = attempts.reduce((sum: number, attempt: { started_at?: string; finished_at?: string }) => {
      if (attempt.started_at && attempt.finished_at) {
        const timeSpent = new Date(attempt.finished_at).getTime() - new Date(attempt.started_at).getTime()
        return sum + timeSpent
      }
      return sum
    }, 0)
    const averageTimeSpent = submittedCount > 0 ? totalTime / submittedCount / 1000 : 0 // Convert to seconds
    const completionRate = totalParticipants > 0 ? (submittedCount / totalParticipants) * 100 : 0

    // Map participants with their results
    const participantsWithResults = participants.map((participant: {
      id: string;
      session_id: string;
      student_id?: string;
      display_name: string;
      joined_at: string;
      status: string;
      last_seen: string;
    }) => {
      const attempt = attempts.find((a: { student_id?: string; student_alias?: string }) => 
        (a.student_id === participant.student_id && participant.student_id) ||
        (a.student_alias === participant.display_name && !participant.student_id)
      ) as { score?: number; finished_at?: string; started_at?: string } | undefined

      return {
        id: participant.id,
        sessionId: participant.session_id,
        studentId: participant.student_id,
        displayName: participant.display_name,
        joinedAt: new Date(participant.joined_at),
        status: participant.status as ParticipantStatus,
        lastSeen: new Date(participant.last_seen),
        score: attempt?.score ?? undefined,
        timeSpent: attempt ? (
          attempt.finished_at && attempt.started_at ? 
          (new Date(attempt.finished_at).getTime() - new Date(attempt.started_at).getTime()) / 1000 : 
          undefined
        ) : undefined,
        completedAt: attempt?.finished_at ? new Date(attempt.finished_at) : undefined
      }
    })

    return {
      classSession: {
        id: classSession.id,
        classId: classSession.class_id,
        sessionId: classSession.session_id,
        quizId: classSession.quiz_id,
        status: classSession.status,
        startedAt: new Date(classSession.started_at),
        endedAt: classSession.ended_at ? new Date(classSession.ended_at) : undefined,
        createdAt: new Date(classSession.created_at)
      },
      stats: {
        totalParticipants,
        submittedCount,
        averageScore,
        averageTimeSpent,
        completionRate
      },
      participants: participantsWithResults
    }
  } catch (error) {
    console.error('Error getting class session results:', error)
    return null
  }
}

/**
 * Get classes that a student is a member of
 */
export async function getStudentClasses(userId?: string): Promise<Class[]> {
  try {
    const supabase = supabaseServer()

    if (!userId) {
      return [] // Guest users can't have persistent class memberships
    }

    const { data: memberships, error: membershipError } = await supabase
      .from('class_members')
      .select(`
        classes(*)
      `)
      .eq('user_id', userId)
      .eq('status', 'active')

    if (membershipError) {
      throw membershipError
    }

    return (memberships as unknown as { classes: {
      id: string;
      owner_id: string;
      org_id?: string;
      name: string;
      grade?: string;
      subject?: string;
      invite_code: string;
      created_at: string;
      updated_at: string;
    }}[])
      .filter((m) => m.classes)
      .map((membership) => ({
        id: membership.classes.id,
        ownerId: membership.classes.owner_id,
        orgId: membership.classes.org_id,
        name: membership.classes.name,
        grade: membership.classes.grade,
        subject: membership.classes.subject,
        inviteCode: membership.classes.invite_code,
        createdAt: new Date(membership.classes.created_at),
        updatedAt: new Date(membership.classes.updated_at)
      }))
  } catch (error) {
    console.error('Error getting student classes:', error)
    return []
  }
}

/**
 * Regenerate invite code for a class
 */
export async function regenerateClassInviteCodeAction(formData: FormData): Promise<CreateClassResult> {
  const classId = formData.get('classId') as string

  if (!classId) {
    return {
      success: false,
      error: 'Klass-ID krävs'
    }
  }

  try {
    const user = await requireTeacher()
    const supabase = supabaseServer()

    // Force update to trigger invite code regeneration
    const { data: classData, error: updateError } = await supabase
      .from('classes')
      .update({ 
        invite_code: '', // This will trigger the function to generate a new code
        updated_at: new Date().toISOString()
      })
      .eq('id', classId)
      .eq('owner_id', user.id)
      .select()
      .single()

    if (updateError || !classData) {
      return {
        success: false,
        error: 'Klassen hittades inte eller du har inte behörighet'
      }
    }

    return {
      success: true,
      class: {
        id: classData.id,
        ownerId: classData.owner_id,
        orgId: classData.org_id,
        name: classData.name,
        grade: classData.grade,
        subject: classData.subject,
        inviteCode: classData.invite_code,
        createdAt: new Date(classData.created_at),
        updatedAt: new Date(classData.updated_at)
      }
    }
  } catch (error) {
    console.error('Error regenerating invite code:', error)
    return {
      success: false,
      error: 'Det gick inte att generera ny inbjudningskod'
    }
  }
}